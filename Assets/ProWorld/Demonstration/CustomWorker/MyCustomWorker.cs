using System;
using System.ComponentModel;
using System.Runtime.Serialization;
using ProWorldSDK;

[Serializable]
public class MyCustomWorker : Worker
{
    private bool _isDone;
    
    // Constructor
    public MyCustomWorker()
    {
        // Workers do work in order of the priority. Low value is run first, same value can run simultaneously.
        // ProWorld workers have values of TerrainWorker = 0; TextureWorker = 4; EntityWorker = 8;
        // Default priority of CustomWorker is 20.
        // Priority = 20;
    }

    public override void Generate(object sender, DoWorkEventArgs e)
    {
        // Generate runs in a seperate thread. You can not run any unity functions in here.
        // This let's you calculate position of objects, run complex algorithms without affect the FPS.

        // e contains WorldData which is a copy of important terrain data generated by ProWorld.
        var data = (WorldData)e.Argument;

        // DOYOURWORK
        
        // Unlock Apply when completed calculations
        _isDone = true;
    }

    public override bool Apply(WorldData data, DateTime startTime, double duration)
    {
        // Runs in primary thread. This is where you can create gameobjects, apply to terrain etc.
        // Returning false tells ProWorld that the work hasn't been completed and to call this function again next frame
        // Return true when work is completed. 

        // You need some type of lock to stop Apply running before Generate is finished. 
        if (!_isDone) return false;

        // DOYOURWORK

        // If your work is going to take too much time you can split it over frames using the provided time data.
        // By default duration is equivelant to 60fps but this doesn't include user logic. 
        // If you have a lot of your own calculations you might want to reduce how much ProWorld can do per frame
        // This is declared at the top of Manager.cs
        
        if ((DateTime.Now - startTime).TotalMilliseconds > duration)
        {
            return false;
        }

        // An example of how you might implement this.
        // For example if you wanted to create lots of npcs but can only do say 15 per frame
        /* while (_npcs.Count > 0)
        {
            var npc = _npcs.Dequeue();

            var npcCopy = UnityEngine.Object.Instantiate(npc.Model, npc.Position, npc.Rotation);
            _npcsToClean.Add(npcCopy); // List of npcs created so we can remove them later in Clean();

            if ((DateTime.Now - startTime).TotalMilliseconds > duration)
            {
                return false;
            }
        }*/

        return true;
    }


    // Optional
    public override void Clean()
    {
        // Runs when a terrain is destroyed. Used to remove your own custom assets if they aren't attached to the terrain
        // You should probably only remove Unity related stuff created in Apply. 
        // In theory this function could run before Generate finishes which the garbage collector should clean up.
    }

    // Worker implements the ISerializable allowing you control your own serialization and deserialization
    // This is important as your worker is cloned for each terrain.
    // You need to serialize any value that is set by default or in the constructor.
    // DO NOT serialize any containers used to pass data between between Generate/Apply/Clean. 
    // Just set this manually in their respective functions.
    // You must call the base virtual function of GetObjectData
    
    // If you have nothing to serialize, you must still implement this Constructor
    // In this case though you can leave out the GetObjectData as the virtual function will still be called.
    #region ISerializable
    public MyCustomWorker(SerializationInfo info, StreamingContext context)
        : base(info, context)
    {
        //_health = (float) info.GetValue("Health", typeof (float));
    }

    public override void GetObjectData(SerializationInfo info, StreamingContext context)
    {
        //info.AddValue("Health", _health);

        base.GetObjectData(info, context);
    }
    #endregion
}